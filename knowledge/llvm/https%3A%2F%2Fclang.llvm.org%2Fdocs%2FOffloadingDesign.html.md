---
title: "Offloading Design & Internals — Clang 22.0.0git documentation"
source: "https://clang.llvm.org/docs/OffloadingDesign.html"
source_tag: "llvm"
license: "Apache-2.0 WITH LLVM-exception"
license_url: "https://llvm.org/LICENSE.txt"
attribution: "LLVM/Clang docs (Apache-2.0 with LLVM exception)"
---
*   [Introduction](#introduction)
    
*   [OpenMP Offloading](#openmp-offloading)
    
    *   [Offloading Overview](#offloading-overview)
        
        *   [Compilation Process](#compilation-process)
            
    *   [Generating Offloading Entries](#generating-offloading-entries)
        
        *   [Accessing Entries on the Device](#accessing-entries-on-the-device)
            
        *   [Debugging Information](#debugging-information)
            
    *   [Offload Device Compilation](#offload-device-compilation)
        
    *   [Creating Fat Objects](#creating-fat-objects)
        
    *   [Linking Target Device Code](#linking-target-device-code)
        
    *   [Device Binary Wrapping](#device-binary-wrapping)
        
        *   [Structure Types](#structure-types)
            
    *   [Global Variables](#global-variables)
        
        *   [Binary Descriptor for Device Images](#binary-descriptor-for-device-images)
            
        *   [Global Constructor and Destructor](#global-constructor-and-destructor)
            
    *   [Offloading Example](#offloading-example)
        
    *   [Relocatable Linking](#relocatable-linking)
        

[Introduction](#id5)[¶](#introduction "Link to this heading")
-------------------------------------------------------------

This document describes the Clang driver and code generation steps for creating offloading applications. Clang supports offloading to various architectures using programming models like CUDA, HIP, and OpenMP. The purpose of this document is to illustrate the steps necessary to create an offloading application using Clang.

[OpenMP Offloading](#id6)[¶](#openmp-offloading "Link to this heading")
-----------------------------------------------------------------------

Clang supports OpenMP target offloading to several different architectures such as NVPTX, AMDGPU, X86\_64, Arm, and PowerPC. Offloading code is generated by Clang and then executed using the `libomptarget` runtime and the associated plugin for the target architecture, e.g. `libomptarget.rtl.cuda`. This section describes the steps necessary to create a functioning device image that can be loaded by the OpenMP runtime. More information on the OpenMP runtimes can be found at the [OpenMP documentation page](https://openmp.llvm.org/).

### [Offloading Overview](#id7)[¶](#offloading-overview "Link to this heading")

The goal of offloading compilation is to create an executable device image that can be run on the target device. OpenMP offloading creates executable images by compiling the input file for both the host and the target device. The output from the device phase then needs to be embedded into the host to create a fat object. A special tool then needs to extract the device code from the fat objects, run the device linking step, and embed the final image in a symbol the host runtime library can use to register the library and access the symbols on the device.

#### [Compilation Process](#id8)[¶](#compilation-process "Link to this heading")

The compiler performs the following high-level actions to generate OpenMP offloading code:

*   Compile the input file for the host to produce a bitcode file. Lower `#pragma omp target` declarations to [offloading entries](#generating-offloading-entries) and create metadata to indicate which entries are on the device.
    
*   Compile the input file for the target [device](#device-compilation) using the [offloading entry](#generating-offloading-entries) metadata created by the host.
    
*   Link the OpenMP device runtime library and run the backend to create a device object file.
    
*   Run the backend on the host bitcode file and create a [fat object file](#creating-fat-objects) using the device object file.
    
*   Pass the fat object file to the [linker wrapper tool](#device-linking) and extract the device objects. Run the device linking action on the extracted objects.
    
*   [Wrap](#device-binary-wrapping) the [device images](#device-linking) and [offload entries](#generating-offloading-entries) in a symbol that can be accessed by the host.
    
*   Add the [wrapped binary](#device-binary-wrapping) to the linker input and run the host linking action. Link with `libomptarget` to register and execute the images.
    

### [Generating Offloading Entries](#id9)[¶](#generating-offloading-entries "Link to this heading")

The first step in compilation is to generate offloading entries for the host. This information is used to identify function kernels or global values that will be provided by the device. Blocks contained in a `#pragma omp target` or symbols inside a `#pragma omp declare target` directive will have offloading entries generated. The following table shows the [offload entry structure](#table-tgt-offload-entry-structure).

> \_\_tgt\_offload\_entry Structure[¶](#table-tgt-offload-entry-structure "Link to this table")
> 
> Type
> 
> Identifier
> 
> Description
> 
> void\*
> 
> addr
> 
> Address of global symbol within device image (function or global)
> 
> char\*
> 
> name
> 
> Name of the symbol
> 
> size\_t
> 
> size
> 
> Size of the entry info (0 if it is a function)
> 
> int32\_t
> 
> flags
> 
> Flags associated with the entry (see [Target Region Entry Flags](#table-offload-entry-flags))
> 
> int32\_t
> 
> reserved
> 
> Reserved, to be used by the runtime library.

The address of the global symbol will be set to the device pointer value by the runtime once the device image is loaded. The flags are set to indicate the handling required for the offloading entry. If the offloading entry is an entry to a target region it can have one of the following [entry flags](#table-offload-entry-flags).

> Target Region Entry Flags[¶](#table-offload-entry-flags "Link to this table")
> 
> Name
> 
> Value
> 
> Description
> 
> OMPTargetRegionEntryTargetRegion
> 
> 0x00
> 
> Mark the entry as generic target region
> 
> OMPTargetRegionEntryCtor
> 
> 0x02
> 
> Mark the entry as a global constructor
> 
> OMPTargetRegionEntryDtor
> 
> 0x04
> 
> Mark the entry as a global destructor

If the offloading entry is a global variable, indicated by a non-zero size, it will instead have one of the following [global](#table-offload-global-flags) flags.

> Target Region Global[¶](#table-offload-global-flags "Link to this table")
> 
> Name
> 
> Value
> 
> Description
> 
> OMPTargetGlobalVarEntryTo
> 
> 0x00
> 
> Mark the entry as a ‘to’ attribute (w.r.t. the to clause)
> 
> OMPTargetGlobalVarEntryLink
> 
> 0x01
> 
> Mark the entry as a ‘link’ attribute (w.r.t. the link clause)

The target offload entries are used by the runtime to access the device kernels and globals that will be provided by the final device image. Each offloading entry is set to use the `omp_offloading_entries` section. When the final application is created the linker will provide the `__start_omp_offloading_entries` and `__stop_omp_offloading_entries` symbols which are used to create the [final image](#device-binary-wrapping).

This information is used by the device compilation stage to determine which symbols need to be exported from the device. We use the `omp_offload.info` metadata node to pass this information device compilation stage.

#### [Accessing Entries on the Device](#id10)[¶](#accessing-entries-on-the-device "Link to this heading")

Accessing the entries in the device is done using the address field in the [offload entry](#table-tgt-offload-entry-structure). The runtime will set the address to the pointer associated with the device image during runtime initialization. This is used to call the corresponding kernel function when entering a `#pragma omp target` region. For variables, the runtime maintains a table mapping host pointers to device pointers. Global variables inside a `#pragma omp target declare` directive are first initialized to the host’s address. Once the device address is initialized we insert it into the table to map the host address to the device address.

#### [Debugging Information](#id11)[¶](#debugging-information "Link to this heading")

We generate structures to hold debugging information that is passed to `libomptarget`. This allows the front-end to generate information the runtime library uses for more informative error messages. This is done using the standard [identifier structure](#table-ident-t-structure) used in `libomp` and `libomptarget`. This is used to pass information and source locations to the runtime.

> ident\_t Structure[¶](#table-ident-t-structure "Link to this table")
> 
> Type
> 
> Identifier
> 
> Description
> 
> int32\_t
> 
> reserved
> 
> Reserved, to be used by the runtime library.
> 
> int32\_t
> 
> flags
> 
> Flags used to indicate some features, mostly unused.
> 
> int32\_t
> 
> reserved
> 
> Reserved, to be used by the runtime library.
> 
> int32\_t
> 
> reserved
> 
> Reserved, to be used by the runtime library.
> 
> char\*
> 
> psource
> 
> Program source information, stored as “;filename;function;line;column;;\\0”

If debugging information is enabled, we will also create strings to indicate the names and declarations of variables mapped in target regions. These have the same format as the source location in the [identifier structure](#table-ident-t-structure), but the function name is replaced with the variable name.

### [Offload Device Compilation](#id12)[¶](#offload-device-compilation "Link to this heading")

The input file is compiled for each active device toolchain. The device compilation stage is performed differently from the host stage. Namely, we do not generate any offloading entries. This is set by passing the `-fopenmp-is-target-device` flag to the front-end. We use the host bitcode to determine which symbols to export from the device. The bitcode file is passed in from the previous stage using the `-fopenmp-host-ir-file-path` flag. Compilation is otherwise performed as it would be for any other target triple.

When compiling for the OpenMP device, we set the visibility of all device symbols to be `protected` by default. This improves performance and prevents a class of errors where a symbol in the target device could preempt a host library.

The OpenMP runtime library is linked in during compilation to provide the implementations for standard OpenMP functionality. For GPU targets this is done by linking in a special bitcode library during compilation, (e.g. `libomptarget-nvptx64-sm_70.bc`) using the `-mlink-builtin-bitcode` flag. Other device libraries, such as CUDA’s libdevice, are also linked this way. If the target is a standard architecture with an existing `libomp` implementation, that will be linked instead. Finally, device tools are used to create a relocatable device object file that can be embedded in the host.

### [Creating Fat Objects](#id13)[¶](#creating-fat-objects "Link to this heading")

A fat binary is a binary file that contains information intended for another device. We create a fat object by embedding the output of the device compilation stage into the host as a named section. The output from the device compilation is passed to the host backend using the `-fembed-offload-object` flag. This embeds the device image into the `.llvm.offloading` section using a special binary format that behaves like a string map. This binary format is used to bundle metadata about the image so the linker can associate the proper device linking action with the image. Each device image will start with the magic bytes `0x10FF10AD`.

@llvm.embedded.object \= private constant \[1 x i8\] c"\\00", section ".llvm.offloading"

The device code will then be placed in the corresponding section one the backend is run on the host, creating a fat object. Using fat objects allows us to treat offloading objects as standard host objects. The final object file should contain the following [offloading sections](#table-offloading-sections). We will use this information when [Linking Target Device Code](#device-linking).

> Offloading Sections[¶](#table-offloading-sections "Link to this table")
> 
> Section
> 
> Description
> 
> omp\_offloading\_entries
> 
> Offloading entry information (see [\_\_tgt\_offload\_entry Structure](#table-tgt-offload-entry-structure))
> 
> .llvm.offloading
> 
> Embedded device object file for the target device and architecture

### [Linking Target Device Code](#id14)[¶](#linking-target-device-code "Link to this heading")

Objects containing [Offloading Sections](#table-offloading-sections) require special handling to create an executable device image. This is done using a Clang tool, see [Clang Linker Wrapper](https://clang.llvm.org/docs/ClangLinkerWrapper.html) for more information. This tool works as a wrapper over the host linking job. It scans the input object files for the offloading section `.llvm.offloading`. The device files stored in this section are then extracted and passed to the appropriate linking job. The linked device image is then [wrapped](#device-binary-wrapping) to create the symbols used to load the device image and link it with the host.

The linker wrapper tool supports linking bitcode files through link time optimization (LTO). This is used whenever the object files embedded in the host contain LLVM bitcode. Bitcode will be embedded for architectures that do not support a relocatable object format, such as AMDGPU or SPIR-V, or if the user requested it using the `-foffload-lto` flag.

### [Device Binary Wrapping](#id15)[¶](#device-binary-wrapping "Link to this heading")

Various structures and functions are used to create the information necessary to offload code on the device. We use the [linked device executable](#device-linking) with the corresponding offloading entries to create the symbols necessary to load and execute the device image.

#### [Structure Types](#id16)[¶](#structure-types "Link to this heading")

Several different structures are used to store offloading information. The [device image structure](#table-device-image-structure) stores a single linked device image and its associated offloading entries. The offloading entries are stored using the `__start_omp_offloading_entries` and `__stop_omp_offloading_entries` symbols generated by the linker using the [\_\_tgt\_offload\_entry Structure](#table-tgt-offload-entry-structure).

> \_\_tgt\_device\_image Structure[¶](#table-device-image-structure "Link to this table")
> 
> Type
> 
> Identifier
> 
> Description
> 
> void\*
> 
> ImageStart
> 
> Pointer to the target code start
> 
> void\*
> 
> ImageEnd
> 
> Pointer to the target code end
> 
> \_\_tgt\_offload\_entry\*
> 
> EntriesBegin
> 
> Begin of table with all target entries
> 
> \_\_tgt\_offload\_entry\*
> 
> EntriesEnd
> 
> End of table (non inclusive)

The target [target binary descriptor](#table-target-binary-descriptor) is used to store all binary images and offloading entries in an array.

> \_\_tgt\_bin\_desc Structure[¶](#table-target-binary-descriptor "Link to this table")
> 
> Type
> 
> Identifier
> 
> Description
> 
> int32\_t
> 
> NumDeviceImages
> 
> Number of device types supported
> 
> \_\_tgt\_device\_image\*
> 
> DeviceImages
> 
> Array of device images (1 per dev. type)
> 
> \_\_tgt\_offload\_entry\*
> 
> HostEntriesBegin
> 
> Begin of table with all host entries
> 
> \_\_tgt\_offload\_entry\*
> 
> HostEntriesEnd
> 
> End of table (non inclusive)

### [Global Variables](#id17)[¶](#global-variables "Link to this heading")

[Global Variables](#table-global-variables) lists various global variables, along with their type and their explicit ELF sections, which are used to store device images and related symbols.

> Global Variables[¶](#table-global-variables "Link to this table")
> 
> Variable
> 
> Type
> 
> ELF Section
> 
> Description
> 
> \_\_start\_omp\_offloading\_entries
> 
> \_\_tgt\_offload\_entry
> 
> .omp\_offloading\_entries
> 
> Begin symbol for the offload entries table.
> 
> \_\_stop\_omp\_offloading\_entries
> 
> \_\_tgt\_offload\_entry
> 
> .omp\_offloading\_entries
> 
> End symbol for the offload entries table.
> 
> \_\_dummy.omp\_offloading.entry
> 
> \_\_tgt\_offload\_entry
> 
> .omp\_offloading\_entries
> 
> Dummy zero-sized object in the offload entries section to force linker to define begin/end symbols defined above.
> 
> .omp\_offloading.device\_image
> 
> \_\_tgt\_device\_image
> 
> .omp\_offloading\_entries
> 
> ELF device code object of the first image.
> 
> .omp\_offloading.device\_image.N
> 
> \_\_tgt\_device\_image
> 
> .omp\_offloading\_entries
> 
> ELF device code object of the (N+1)th image.
> 
> .omp\_offloading.device\_images
> 
> \_\_tgt\_device\_image
> 
> .omp\_offloading\_entries
> 
> Array of images.
> 
> .omp\_offloading.descriptor
> 
> \_\_tgt\_bin\_desc
> 
> .omp\_offloading\_entries
> 
> Binary descriptor object (see [Binary Descriptor for Device Images](#binary-descriptor))

#### [Binary Descriptor for Device Images](#id18)[¶](#binary-descriptor-for-device-images "Link to this heading")

This object is passed to the offloading runtime at program startup and it describes all device images available in the executable or shared library. It is defined as follows:

\_\_attribute\_\_((visibility("hidden")))
extern \_\_tgt\_offload\_entry \*\_\_start\_omp\_offloading\_entries;
\_\_attribute\_\_((visibility("hidden")))
extern \_\_tgt\_offload\_entry \*\_\_stop\_omp\_offloading\_entries;
static const char Image0\[\] \= { <Bufs.front() contents\> };
...
static const char ImageN\[\] \= { <Bufs.back() contents\> };
static const \_\_tgt\_device\_image Images\[\] \= {
  {
    Image0,                            /\*ImageStart\*/
    Image0 + sizeof(Image0),           /\*ImageEnd\*/
    \_\_start\_omp\_offloading\_entries,    /\*EntriesBegin\*/
    \_\_stop\_omp\_offloading\_entries      /\*EntriesEnd\*/
  },
  ...
  {
    ImageN,                            /\*ImageStart\*/
    ImageN + sizeof(ImageN),           /\*ImageEnd\*/
    \_\_start\_omp\_offloading\_entries,    /\*EntriesBegin\*/
    \_\_stop\_omp\_offloading\_entries      /\*EntriesEnd\*/
  }
};
static const \_\_tgt\_bin\_desc BinDesc \= {
  sizeof(Images) / sizeof(Images\[0\]),  /\*NumDeviceImages\*/
  Images,                              /\*DeviceImages\*/
  \_\_start\_omp\_offloading\_entries,      /\*HostEntriesBegin\*/
  \_\_stop\_omp\_offloading\_entries        /\*HostEntriesEnd\*/
};

#### [Global Constructor and Destructor](#id19)[¶](#global-constructor-and-destructor "Link to this heading")

The global constructor (`.omp_offloading.descriptor_reg()`) registers the device images with the runtime by calling the `__tgt_register_lib()` runtime function. The constructor is explicitly defined in `.text.startup` section and is run once when the program starts. Similarly, the global destructor (`.omp_offloading.descriptor_unreg()`) calls `__tgt_unregister_lib()` for the destructor and is also defined in `.text.startup` section and run when the program exits.

### [Offloading Example](#id20)[¶](#offloading-example "Link to this heading")

This section contains a simple example of generating offloading code using OpenMP offloading. We will use a simple `ZAXPY` BLAS routine.

#include <complex>

using complex \= std::complex<double\>;

void zaxpy(complex \*X, complex \*Y, complex D, std::size\_t N) {
#pragma omp target teams distribute parallel for
  for (std::size\_t i \= 0; i < N; ++i)
    Y\[i\] \= D \* X\[i\] + Y\[i\];
}

int main() {
  const std::size\_t N \= 1024;
  complex X\[N\], Y\[N\], D;
#pragma omp target data map(to:X\[0 : N\]) map(tofrom:Y\[0 : N\])
  zaxpy(X, Y, D, N);
}

This code is compiled using the following Clang flags.

$ clang++ \-fopenmp \-fopenmp-targets\=nvptx64 \-O3 zaxpy.cpp \-c

The output section in the object file can be seen using the `readelf` utility. The `.llvm.offloading` section has the `SHF_EXCLUDE` flag so it will be removed from the final executable or shared library by the linker.

$ llvm-readelf -WS zaxpy.o
Section Headers:
\[Nr\] Name                   Type     Address          Off    Size   ES Flg Lk Inf Al
\[11\] omp\_offloading\_entries PROGBITS 0000000000000000 0001f0 000040 00   A  0   0  1
\[12\] .llvm.offloading       PROGBITS 0000000000000000 000260 030950 00   E  0   0  8

Compiling this file again will invoke the `clang-linker-wrapper` utility to extract and link the device code stored at the section named `.llvm.offloading` and then use entries stored in the section named `omp_offloading_entries` to create the symbols necessary for `libomptarget` to register the device image and call the entry function.

$ clang++ \-fopenmp \-fopenmp-targets\=nvptx64 zaxpy.o \-o zaxpy
$ ./zaxpy

We can see the steps created by clang to generate the offloading code using the `-ccc-print-phases` option in Clang. This matches the description in [Offloading Overview](#offloading-overview).

$ clang++ \-fopenmp \-fopenmp-targets\=nvptx64 \-ccc-print-phases zaxpy.cpp
\# "x86\_64-unknown-linux-gnu" \- "clang", inputs: \["zaxpy.cpp"\], output: "/tmp/zaxpy-host.bc"
\# "nvptx64-nvidia-cuda" \- "clang", inputs: \["zaxpy.cpp", "/tmp/zaxpy-e6a41b.bc"\], output: "/tmp/zaxpy-07f434.s"
\# "nvptx64-nvidia-cuda" \- "NVPTX::Assembler", inputs: \["/tmp/zaxpy-07f434.s"\], output: "/tmp/zaxpy-0af7b7.o"
\# "x86\_64-unknown-linux-gnu" \- "clang", inputs: \["/tmp/zaxpy-e6a41b.bc", "/tmp/zaxpy-0af7b7.o"\], output: "/tmp/zaxpy-416cad.o"
\# "x86\_64-unknown-linux-gnu" \- "Offload::Linker", inputs: \["/tmp/zaxpy-416cad.o"\], output: "a.out"

### [Relocatable Linking](#id21)[¶](#relocatable-linking "Link to this heading")

The offloading compilation pipeline normally will defer the final device linking and runtime registration until the `clang-linker-wrapper` is run to create the executable. This is the standard behaviour when compiling for OpenMP offloading or CUDA and HIP in `-fgpu-rdc` mode. However, there are some cases where the user may wish to perform this device handling prematurely. This is described in the [linker wrapper documentation](https://clang.llvm.org/docs/ClangLinkerWrapper.html).

Effectively, this allows the user to handle offloading specific linking ahead of time when shipping objects or static libraries. This can be thought of as performing a standard `-fno-gpu-rdc` compilation on a subset of object files. This can be useful to reduce link time, prevent users from interacting with the library’s device code, or for shipping libraries to incompatible compilers.

Normally, if a relocatable link is done using `clang -r` it will simply merge the `.llvm.offloading` sections which will then be linked later when the executable is created. However, if the `-r` flag is used with the offloading toolchain, it will perform the device linking and registration phases and then merge the registration code into the final relocatable object file.

The following example shows how using the relocatable link with the offloading pipeline can create a static library with offloading code that can be redistributed without requiring any additional handling.

$ clang++ \-fopenmp \-fopenmp-targets\=nvptx64 foo.cpp \-c
$ clang++ \-lomptarget.devicertl \--offload-link \-r foo.o \-o merged.o
$ llvm-ar rcs libfoo.a merged.o
\# g++ app.cpp \-L. \-lfoo